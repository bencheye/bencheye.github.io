---
layout: post
title: "linux常用命令及使用"
date: 2021-09-19
description: "linux常用命令、使用方法总结"
---

1. 打包压缩

   `tar`

   ```shell
   -c # 建立打包文件
   -t # 查看打包的文件内容含有哪些文件名
   -x # 解包或者解压缩，可搭配-c在特定目录解压
   -z # 通过gzip进行压缩、解压缩
   -v # 在压缩、解压缩过程中将处理的文件名显示
   -f # 后理解接待处理文件名
   # 压缩文件
   tar -zcv -f filename.tar.gz(压缩后文件名) 要被压缩的文件或者目录
   # 解压缩
   tar -zxv -f filename.tar.gz(待压缩文件名) -C 欲解压目录
   ```

2. vim用法

   1. 移动光标

      ```shell
      h 向左; j 向下； k向上； I 向右
      ctrl + f 下一页； ctrl + b 上一页
      + 上一行； - 下一行
      20<空格> 向右移动20个字符，20可以替换为n
      0[数字] 移至行首； $ 移至行尾
      G 移到文件最后一行； nG移动到文件第n行
      gg 移动到第一行； n<Enter> 向下移动n行
      ```

   2. 查找替换

      ```
      /word 向下查找word字符串
      n/N 正向/反向重复上一个查找
      :n1,n2s/word1/word2/g 在n1与n2行之间查找word1并替换为word2
      /g 直接替换 /gc 询问是否替换
      ```

   3. 删除

      ```
      x/X x向后删除一个字符，等同del；X向前删除一个字符，等同backspace
      nx 向后删除n个字符
      dd 删除整行 ndd 向下删除n行
      yy 复制光标所在行 nyy 向下复制n行
      p/P p将复制内容贴于光标所在下一行， P贴于上一行
      u 恢复前一个动作， ctrl+r 重做上一个动作
      . 重复上一个操作
      ```

   4. 编辑模式

      ```
      i/I i从目前光标所在处插入
      a/A 
      :set nu 显示行号
      :set nonu 取消显示行号
      ```

3. bash常用命令

   ```
   ctrl + u/k 从光标处向前删除命令；向后
   ctrl + a/e 光标移动到整个命令最前面、后面
   ctrl + c 终止目前命令
   ctrl + m 回车
   ctrl + s 暂停屏幕输出
   ctrl + q 恢复屏幕输出
   ```

4. 变量

   ```
   # 赋值
   变量名=value # 中间不能有空格
   # 使用变量
   $变量名 or ${变量名}
   # 双引号与单引号
   "$变量名" 与 '$变量名'； 前者可以输出变量的值，而后者输出是字符串的$变量名本身
   # 将其它命令的值作为value
   变量名=`命令` OR 变量名=$(命令)
   ```

   注意：

   若该变量需要在其他子程序执行时，用export使该变量变成环境变量；在一个shell启用一个新的shell，新的shell是子进程，父进程中自定义变量无法在子进程中使用，通过export转变成环境变量可以使用。子进程仅继承父进程的环境变量

5. read与用户交互

   ```
   -p 后面接提示语
   -t 等待时间
   read -p "please keyin " -t 30 named（变量名）
   ```

6. declare用法

   ```
   -a 将后面的变量定义为数组array
   -i 将后面的变量定义为整数； eg. decale -i sum=100+300; OR sum=$((100+300))
   ```

7. 命令查找顺序

   1. 相对路径、绝对路径执行命令
   2. 由alias找到该命令并执行
   3. 由bash内置命令执行
   4. 通过$PATH顺序找到的第一个命令执行

8. 通配符

   ```
   * 0个到无穷多个任意字符
   ? 一个任意字符
   [] 一定有一个字符在括号内；eg. [abcd] 一定有一个字符，可能是a-d
   [-] 在编码顺序内的所有字符中一个；eg. [a-z] 一定有一个a-z字符
   [^] 表示反向选择；在外面这是首个字符
   ```

9. 符号

   ```
   # 注释； \ 转义符号，将特殊字符转为一般字符
   | 管道； ~ 家目录； & 将命令变为后台运行，通常与wait一起，表示等上一步命令运行完再继续
   > 替换； >> 累加； 2>1 将标准错误重定向到1正常输出
   () 子shell起始与结束； {} 命令区块的组合； [] 判断符号
   ```

10. 判断

    ```
    && 且； || 或
    if [ $a == 0 ] || [ $b == 1]
    ```

11. cut 数据切片

    ```
    cut -d '分隔符' -f fileds； eg. cat file | cut -d ':' -f 3,5 分割后选择3到5列
    cut -c 取字符串某个区间； eg. cut -c 12-20 取12-20的字符
    ```

12. grep 分析一行信息，有我们想要的数据拿出来

    ```
    -n 输出行号； -v 取反； -i 忽略大小写； -c 查找字符出现次数
    grep [-acinv] [--color=auto] '查找字符' filename
    ```

13. sort 排序

    ```
    -f 忽略大小写； -b 忽略前面的空格字符； -M 按照月份排序； -n 纯数字排序； -t 分隔符； -k 哪个区间排序
    sort -t ':' -k 3 filename
    ```

14. uniq 去重

    ```
    -i 忽略大小写字符； -c 进行计数
    last | cut -d ' ' -f 1 | sort | uniq -c
    ```

15. wc 统计多少字、行和字符

    ```
    -l 仅列出行； -w 仅列出多少英文字母； -m 多少字符
    ```

16. tee 双重定向，中间同时输出一份结果存储，并有一份传递给下游

    ```
    -a 以累加的方式写入
    ls -l /home | tee ~/homefile | more
    ```

17. tr 删除一段信息中的文字

    ```
    -d 删除当中的文字； -s 替换掉重复的字符
    tr '[a-z]' '[A-Z]' file 小写转大写
    tr -d ':' 删除':'
    ```

18. join 将两个文件共有列相加，有相同数据的那一行相加

    ```
    -t 分隔符，两个相同则连成一行，且第一栏位放在第一个
    -i 忽略大小写； -1 第一个文件用第几列分析； -2 第二个文件用第几列文件分析
    join [-ti12] file1 file2
    ```

19. paste 直接将两行贴在一起，中间以tab分割

    ```
    -d 直接指定分隔符; - 表示来自标准输入（管道传入）
    cat file1 | paste - file2
    ```

20. xargs 对于有些不能使用管道传入参数的命名，读入管道传入的标准输入

    ```
    -e 接一个字符，当xargs分析到该字符时停止
    -p 执行每个命令时询问使用者
    -n 接次数
    cut -d ':' -f 1 filename | head -n 3 | xargs -p -n | id
    ```

21. 正则表达式

    ```
    ^ 在正则表达式中表示行首；在[]中是取反
    ^$ 表示空白行，$ 表示行尾
    . 代表一定有一个任意字符； * 重复前一个字符，0~无穷多次
    .* 代表任意多个任意字符
    {} 限定范围，需要使用'\{\}' 
    grep -n '0\{2,5\}' 0重复2-5次
    ```

22. sed 替换、删除、新增、选取特定行

    ```
    -n 只有经过特殊处理的行才会被输入到屏幕上；而不是输出所有的行
    -e 直接在命令行模式进行sed编辑
    -f 直接将sed操作写在一个文件内
    -i 直接修改读取文件内容，而不是屏幕输出
    # 操作
    a 新增，后面接字符，这些字符将在新的一行出现（后一行）
    d 删除，通常不接任何东西
    c 替换，接字符，替换n1~n2之间的行
    i 插入，接字符，会出现在上一行
    p 打印，将某个选择的数据打印出来，常与-n连用
    s 替换，直接进行替换工作，可搭配正则表达式
    cat file | sed '2,5d' 删除2-5行
    sed '2a drink tea?' 在第二行后插入
    sed 's/#.*$//g' | sed 's/^$//g' 将#注释内容删除
    ```

23. awk 

    > 处理每一行字段内的数据（列），默认字段分隔符是`<空格>` 或`\t`
    >
    > akw '条件类型1{操作1}条件类型2{操作2}...' filename
    >
    > $1,$2... 表示第几个字段（列）； $0表示一整行数据

    ```
    awk 'NR==1{print $1"\t"$2"\t"$3"\tTotal"}NR>=2{total=$2+$3 print $1"\t"$2"\t"$3"\t"total}'
    第一行只是说明表头不处理，仅打印表头，第二行以后求和
    ```
-  awk处理流程：

  1. 运行BEGIN{}部分，然后运行{},最后运行END{}

     ```
     awk 'BEGIN{运行前}{运行中}END{运行后}' 读入第一行，并将第一行数据根据`FS`指定分割切片，将数据写入对应$0, $1, $2..变量中
     ```

  2. 根据条件类型限制，判断是否需要进行后面的操作

  3. 完成所有操作与条件类型

  4. 若还有后续行的数据，重复1~3，直到完成所有数据读完未知

- awk内置变量：

  1. NF 每一行拥有的字段总数，列数

  2. NR 目前awk处理的是第几行

  3. FS目前的默认分割字符，默认为空格

     ```
      awk '{print $1 "\t lines:" NR "\t columns:" NF}'
     ```

- awk逻辑运算符

  - `>` 大于； `<`小于；  `==`等于； `!=`不等于

    ```
     awk FS=':'$3<10{print $1 '\t' '$3'} filename #以':'为分隔符，取第3列下小于10的数据
          注意： 第一行没正确识别显示，因为读入第一行时，那些变量默认还是使用'空格'分割，虽然定义了FS=':'，但是仅能在第二行开始生效，可利用BEGIN预先设置awk变量
      awk 'BEGIN {FS=':'}$3<10{print $1 '\t' $3}'
    ```

- 注意事项：

  - 格式化输出时，在print格式设置中，务必加上`\n`才能换行

  - 与shell不同，awk中变量可直接使用，不需要加`$`

  - awk`{}`中也支持`if`、`for`等结构

    ```
    awk '{if(NR==1) print'
    ```

24. diff 比较两个文件的差异

    ```
    -b 忽略一行中仅有空白的差异
    -B忽略空白行的差异
    -忽略大小写的差异
    diff password.old password.new
    ```

## shell script

1. shell 脚本编写习惯-脚本开头处记录

   - 脚本的功能
   - 版本信息
   - 作者联系方式
   - 版权声明
   - 历史记录
   - 脚本内特殊命令，使用绝对路径方式运行
   - 脚本运行时需要的环境变量预先声明与设置

2. shell范例

   1. 交互式脚本，变量内容由用户决定、输入

      ```
      read -p 'please input your name:' firstname
      ```

   2. 随日期变化

      利用date命令取的所需文件名

      ```
      date=$(date+%Y%m%d) # 今天日期
      file=${filename}_${date}
      ```

   3. 数字运算

      ```
      1. total=$((${firstNu}*${secondNu}))
      2. declare -i total=${firstNu}*${secondNu}
      ```

   4. 脚本执行方式差异

      - 直接执行方式来执行脚本，如绝对路径、sh等

        这种方式执行脚本，该脚本会在一个新的子进程中进行，当子进程完成后，子进程中各项变量或操作将结束，不会传回父进程

      - source(.) 执行脚本，在父进程中执行

        例如，~/.bashrc 写入内容后，需要使用`source ~/.bashrc`生效

3. 判断

   1. 文件名的`文件类型判断`

      ```
      -e 文件名是否存在； -f 文件名是否存在且为文件；
      -d 文件夹是否存在； -s 文件名是否存在且为非空
      ```

   2. 整数判断

      ```
      -eq 两数值是否相等； -ne 两数值不相等
      -gt 大于； -lt 小于
      -ge 大于等于； -le 小于等于
      a -gt b # 判断a是否大于b； 等价于 [ a > b ]
      ```

   3. 字符串

      ```
      -z 若字符串为空，则为真；# test -z string
      -n 若字符串为空，则为false； test -n string
      test str1 == str2 字符串是否相等
      test str1 != str2
      ```

   4. 多重条件

      ```
      -a (and)两个条件同时成立为真，等于 &&； test -r file -a -x file
      -o (or);等同于 ||
      ! 取反
      ```

   5. 判断符号---[]

      **注意：**

      1. 判断符号中括号两端，以及内部每个组件，都需要有`<空格符>`来分割
      2. 中括号内部的变量最好用`""` `(双引号)`括起来

      ```
      [ a != b ]
      ```

4. shell脚本默认变量

   ```
   /test.sh opt1 opt2 opt3
   $0 脚本文件名
   $@ 全部参数内容
   $1/$2/$3 对应于opt1/opt2/opt3
   $# 参数输入个数，为脚本参数个数+1（$0）
   if [ "$#" ! -lt 2 ];then "The number of parameters are less than 2";fi
   ```

5. 判断语句

   1. if语句

      ```
      if [ condition ] ;then 程序段;elif 程序段;esle 程序段;fi
      ```

   2. case...esac

      ```
      case $变量名称 in
      	'第一个变量内容')
      	程序段
      	；；            # 每个类型结尾使用两个连续的分号来处理
      	'第二个变量内容'）
      	程序段
      	；；
      	*)            # 使用*表示其他值
      	程序段
      	；；
      esac
      ```

6. 循环

   - while循环

     ```
     while [ condition ]  #条件成立时开始循环，直到不成立才停止
     do
     	程序段
     done
     # 累加求和
     s=0
     i=0
     while [ "${i}" != "100" ]
     do
     	i=$(($i+1))
     	s=$(($i+$s))
     done
     ```

   - for循环

     ```
     for var in con1 con2   # 第一次循环$var内容为con1，第二次为con2
     do
     	程序段
     done
     # 1 2 ... 10 可以使用 `seq 1 10` 或者 {1..10}
     for(i=0;i<10;i++)
     do
     	程序段
     done
     # 例子
     user=$(cut -d ':' -f 1 /etc/passwd)
     for username in ${user}
     do
     	echo $username
     done
     # 读入文件
     cat filename | while read column1 column2 ...
     # 配合数组使用
     name=$((ls *.gz))
     for i `seq 1 10`
     do 
     	echo ${name[i]}
     done
     ```

   - 重定向

     ```
     sh test.sh >> test.log 2>1 # 将`test.sh`脚本屏幕输出内容写入test.log；并将标准错误重定向到test.log
     ```

     

   



